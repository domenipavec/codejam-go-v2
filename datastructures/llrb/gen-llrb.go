// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package llrb

import "github.com/matematik7/codejam-go-v2/datastructures/slice"

// LLRBInt tree
type LLRBInt struct {
	Root *NodeInt
}

// NodeInt node
type NodeInt struct {
	Value int
	Left  *NodeInt
	Right *NodeInt
	Red   bool
	Count int
}

// IteratorCallbackInt iterator
type IteratorCallbackInt func(v int) bool

// NewInt construct new llrb
func NewInt() *LLRBInt {
	return &LLRBInt{}
}

// NewNodeInt construct new node
func NewNodeInt(v int) *NodeInt {
	return &NodeInt{
		Value: v,
		Red:   true,
		Count: 1,
	}
}

// Len returns number of elements in tree
func (llrb LLRBInt) Len() int {
	return llrb.Root.Len()
}

// Insert an element
func (llrb *LLRBInt) Insert(v int) {
	n := NewNodeInt(v)
	llrb.Root = llrb.Root.insert(n)
	llrb.Root.Red = false
}

// Delete an element
func (llrb *LLRBInt) Delete(v int) {
	llrb.Root = llrb.Root.delete(v)
	llrb.Root.Red = false
}

// Min element
func (llrb LLRBInt) Min() int {
	min := llrb.Root.Min()
	return min.Value
}

// Max element
func (llrb LLRBInt) Max() int {
	max := llrb.Root.Max()
	return max.Value
}

// Search if element in tree
func (llrb LLRBInt) Search(v int) bool {
	return llrb.Root.Search(v)
}

// Get i-th smallest element
func (llrb LLRBInt) Get(i int) int {
	return llrb.Root.Get(i).Value
}

// Rank of v in tree
func (llrb LLRBInt) Rank(v int) int {
	return llrb.Root.Rank(v)
}

// IterateAsc iterates ascending
func (llrb LLRBInt) IterateAsc(cb IteratorCallbackInt) {
	llrb.Root.IterateAsc(cb)
}

// IterateDesc iterates ascending
func (llrb LLRBInt) IterateDesc(cb IteratorCallbackInt) {
	llrb.Root.IterateDesc(cb)
}

// Len returns number of elements under node inclusive
func (node *NodeInt) Len() int {
	if node == nil {
		return 0
	}
	return node.Count
}

// IsRed checks if node is red
func (node *NodeInt) IsRed() bool {
	if node == nil {
		return false
	}
	return node.Red
}

// Min returns min element
func (node *NodeInt) Min() *NodeInt {
	if node.Left == nil {
		return node
	}
	return node.Left.Min()
}

// Max returns max element
func (node *NodeInt) Max() *NodeInt {
	if node.Right == nil {
		return node
	}
	return node.Right.Max()
}

func (node *NodeInt) refreshCount() {
	node.Count = node.Left.Len() + node.Right.Len() + 1
}

func (node *NodeInt) rotateLeft() *NodeInt {
	x := node.Right
	node.Right = x.Left
	x.Left = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeInt) rotateRight() *NodeInt {
	x := node.Left
	node.Left = x.Right
	x.Right = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeInt) flipColors() {
	node.Red = !node.Red
	if node.Left != nil {
		node.Left.Red = !node.Left.Red
	}
	if node.Right != nil {
		node.Right.Red = !node.Right.Red
	}
}

func (node *NodeInt) insert(newNode *NodeInt) *NodeInt {
	if node == nil {
		return newNode
	}

	cmp := newNode.Compare(node.Value)
	if cmp == 0 {
		return node
	} else if cmp < 0 {
		node.Left = node.Left.insert(newNode)
	} else {
		node.Right = node.Right.insert(newNode)
	}

	node.refreshCount()

	if node.Right.IsRed() && !node.Left.IsRed() {
		node = node.rotateLeft()
	}
	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

func (node *NodeInt) moveRedLeft() *NodeInt {
	node.flipColors()
	if node.Right != nil && node.Right.Left.IsRed() {
		node.Right = node.Right.rotateRight()
		node = node.rotateLeft()
		node.flipColors()
	}
	return node
}

func (node *NodeInt) moveRedRight() *NodeInt {
	node.flipColors()
	if node.Left != nil && node.Left.Left.IsRed() {
		node = node.rotateRight()
		node.flipColors()
	}
	return node
}

func (node *NodeInt) delete(v int) *NodeInt {
	if node.Compare(v) > 0 {
		if node.Left == nil {
			return node
		}
		if !node.Left.IsRed() && !node.Left.Left.IsRed() {
			node = node.moveRedLeft()
		}
		node.Left = node.delete(v)
	} else {
		if node.Left.IsRed() {
			node = node.rotateRight()
		}
		if node.Compare(v) == 0 && node.Right == nil {
			return nil
		}
		if node.Right != nil {
			if !node.Right.IsRed() && !node.Right.Left.IsRed() {
				node = node.moveRedRight()
			}
			if node.Compare(v) == 0 {
				node.Value = node.Right.Min().Value
				node.Right = node.Right.deleteMin()
			} else {
				node.Right = node.Right.delete(v)
			}
		}
	}
	return node.fixUp()
}

func (node *NodeInt) deleteMin() *NodeInt {
	if node.Left == nil {
		return nil
	}

	if !node.Left.IsRed() && !node.Left.Left.IsRed() {
		node = node.moveRedLeft()
	}

	node.Left = node.Left.deleteMin()

	return node.fixUp()
}

func (node *NodeInt) fixUp() *NodeInt {
	node.refreshCount()

	if node.Right.IsRed() {
		node = node.rotateLeft()
	}

	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

// Search if v in tree
func (node *NodeInt) Search(v int) bool {
	if node == nil {
		return false
	}

	cmp := node.Compare(v)
	if cmp == 0 {
		return true
	}
	if cmp < 0 {
		return node.Left.Search(v)
	}
	return node.Right.Search(v)
}

// Get i-th smallest value
func (node *NodeInt) Get(i int) *NodeInt {
	r := node.Left.Len() + 1
	if i == r {
		return node
	}
	if i < r {
		return node.Left.Get(i)
	}
	return node.Right.Get(i - r)
}

// Rank of v in tree
func (node *NodeInt) Rank(v int) int {
	if node == nil {
		return -1
	}

	r := node.Left.Len() + 1

	cmp := node.Compare(v)
	if cmp == 0 {
		return r
	}
	if cmp < 0 {
		return node.Left.Rank(v)
	}
	return node.Right.Rank(v) + r
}

// IterateAsc iterate ascending
func (node *NodeInt) IterateAsc(cb IteratorCallbackInt) bool {
	if node != nil {
		cont := node.Left.IterateAsc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Right.IterateAsc(cb)
	}
	return true
}

// IterateDesc iterate descending
func (node *NodeInt) IterateDesc(cb IteratorCallbackInt) bool {
	if node != nil {
		cont := node.Right.IterateDesc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Left.IterateDesc(cb)
	}
	return true
}

// LLRBSliceSliceInt tree
type LLRBSliceSliceInt struct {
	Root *NodeSliceSliceInt
}

// NodeSliceSliceInt node
type NodeSliceSliceInt struct {
	Value slice.SliceInt
	Left  *NodeSliceSliceInt
	Right *NodeSliceSliceInt
	Red   bool
	Count int
}

// IteratorCallbackSliceSliceInt iterator
type IteratorCallbackSliceSliceInt func(v slice.SliceInt) bool

// NewSliceSliceInt construct new llrb
func NewSliceSliceInt() *LLRBSliceSliceInt {
	return &LLRBSliceSliceInt{}
}

// NewNodeSliceSliceInt construct new node
func NewNodeSliceSliceInt(v slice.SliceInt) *NodeSliceSliceInt {
	return &NodeSliceSliceInt{
		Value: v,
		Red:   true,
		Count: 1,
	}
}

// Len returns number of elements in tree
func (llrb LLRBSliceSliceInt) Len() int {
	return llrb.Root.Len()
}

// Insert an element
func (llrb *LLRBSliceSliceInt) Insert(v slice.SliceInt) {
	n := NewNodeSliceSliceInt(v)
	llrb.Root = llrb.Root.insert(n)
	llrb.Root.Red = false
}

// Delete an element
func (llrb *LLRBSliceSliceInt) Delete(v slice.SliceInt) {
	llrb.Root = llrb.Root.delete(v)
	llrb.Root.Red = false
}

// Min element
func (llrb LLRBSliceSliceInt) Min() slice.SliceInt {
	min := llrb.Root.Min()
	return min.Value
}

// Max element
func (llrb LLRBSliceSliceInt) Max() slice.SliceInt {
	max := llrb.Root.Max()
	return max.Value
}

// Search if element in tree
func (llrb LLRBSliceSliceInt) Search(v slice.SliceInt) bool {
	return llrb.Root.Search(v)
}

// Get i-th smallest element
func (llrb LLRBSliceSliceInt) Get(i int) slice.SliceInt {
	return llrb.Root.Get(i).Value
}

// Rank of v in tree
func (llrb LLRBSliceSliceInt) Rank(v slice.SliceInt) int {
	return llrb.Root.Rank(v)
}

// IterateAsc iterates ascending
func (llrb LLRBSliceSliceInt) IterateAsc(cb IteratorCallbackSliceSliceInt) {
	llrb.Root.IterateAsc(cb)
}

// IterateDesc iterates ascending
func (llrb LLRBSliceSliceInt) IterateDesc(cb IteratorCallbackSliceSliceInt) {
	llrb.Root.IterateDesc(cb)
}

// Len returns number of elements under node inclusive
func (node *NodeSliceSliceInt) Len() int {
	if node == nil {
		return 0
	}
	return node.Count
}

// IsRed checks if node is red
func (node *NodeSliceSliceInt) IsRed() bool {
	if node == nil {
		return false
	}
	return node.Red
}

// Min returns min element
func (node *NodeSliceSliceInt) Min() *NodeSliceSliceInt {
	if node.Left == nil {
		return node
	}
	return node.Left.Min()
}

// Max returns max element
func (node *NodeSliceSliceInt) Max() *NodeSliceSliceInt {
	if node.Right == nil {
		return node
	}
	return node.Right.Max()
}

func (node *NodeSliceSliceInt) refreshCount() {
	node.Count = node.Left.Len() + node.Right.Len() + 1
}

func (node *NodeSliceSliceInt) rotateLeft() *NodeSliceSliceInt {
	x := node.Right
	node.Right = x.Left
	x.Left = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeSliceSliceInt) rotateRight() *NodeSliceSliceInt {
	x := node.Left
	node.Left = x.Right
	x.Right = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeSliceSliceInt) flipColors() {
	node.Red = !node.Red
	if node.Left != nil {
		node.Left.Red = !node.Left.Red
	}
	if node.Right != nil {
		node.Right.Red = !node.Right.Red
	}
}

func (node *NodeSliceSliceInt) insert(newNode *NodeSliceSliceInt) *NodeSliceSliceInt {
	if node == nil {
		return newNode
	}

	cmp := newNode.Compare(node.Value)
	if cmp == 0 {
		return node
	} else if cmp < 0 {
		node.Left = node.Left.insert(newNode)
	} else {
		node.Right = node.Right.insert(newNode)
	}

	node.refreshCount()

	if node.Right.IsRed() && !node.Left.IsRed() {
		node = node.rotateLeft()
	}
	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

func (node *NodeSliceSliceInt) moveRedLeft() *NodeSliceSliceInt {
	node.flipColors()
	if node.Right != nil && node.Right.Left.IsRed() {
		node.Right = node.Right.rotateRight()
		node = node.rotateLeft()
		node.flipColors()
	}
	return node
}

func (node *NodeSliceSliceInt) moveRedRight() *NodeSliceSliceInt {
	node.flipColors()
	if node.Left != nil && node.Left.Left.IsRed() {
		node = node.rotateRight()
		node.flipColors()
	}
	return node
}

func (node *NodeSliceSliceInt) delete(v slice.SliceInt) *NodeSliceSliceInt {
	if node.Compare(v) > 0 {
		if node.Left == nil {
			return node
		}
		if !node.Left.IsRed() && !node.Left.Left.IsRed() {
			node = node.moveRedLeft()
		}
		node.Left = node.delete(v)
	} else {
		if node.Left.IsRed() {
			node = node.rotateRight()
		}
		if node.Compare(v) == 0 && node.Right == nil {
			return nil
		}
		if node.Right != nil {
			if !node.Right.IsRed() && !node.Right.Left.IsRed() {
				node = node.moveRedRight()
			}
			if node.Compare(v) == 0 {
				node.Value = node.Right.Min().Value
				node.Right = node.Right.deleteMin()
			} else {
				node.Right = node.Right.delete(v)
			}
		}
	}
	return node.fixUp()
}

func (node *NodeSliceSliceInt) deleteMin() *NodeSliceSliceInt {
	if node.Left == nil {
		return nil
	}

	if !node.Left.IsRed() && !node.Left.Left.IsRed() {
		node = node.moveRedLeft()
	}

	node.Left = node.Left.deleteMin()

	return node.fixUp()
}

func (node *NodeSliceSliceInt) fixUp() *NodeSliceSliceInt {
	node.refreshCount()

	if node.Right.IsRed() {
		node = node.rotateLeft()
	}

	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

// Search if v in tree
func (node *NodeSliceSliceInt) Search(v slice.SliceInt) bool {
	if node == nil {
		return false
	}

	cmp := node.Compare(v)
	if cmp == 0 {
		return true
	}
	if cmp < 0 {
		return node.Left.Search(v)
	}
	return node.Right.Search(v)
}

// Get i-th smallest value
func (node *NodeSliceSliceInt) Get(i int) *NodeSliceSliceInt {
	r := node.Left.Len() + 1
	if i == r {
		return node
	}
	if i < r {
		return node.Left.Get(i)
	}
	return node.Right.Get(i - r)
}

// Rank of v in tree
func (node *NodeSliceSliceInt) Rank(v slice.SliceInt) int {
	if node == nil {
		return -1
	}

	r := node.Left.Len() + 1

	cmp := node.Compare(v)
	if cmp == 0 {
		return r
	}
	if cmp < 0 {
		return node.Left.Rank(v)
	}
	return node.Right.Rank(v) + r
}

// IterateAsc iterate ascending
func (node *NodeSliceSliceInt) IterateAsc(cb IteratorCallbackSliceSliceInt) bool {
	if node != nil {
		cont := node.Left.IterateAsc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Right.IterateAsc(cb)
	}
	return true
}

// IterateDesc iterate descending
func (node *NodeSliceSliceInt) IterateDesc(cb IteratorCallbackSliceSliceInt) bool {
	if node != nil {
		cont := node.Right.IterateDesc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Left.IterateDesc(cb)
	}
	return true
}

// LLRBFloat64 tree
type LLRBFloat64 struct {
	Root *NodeFloat64
}

// NodeFloat64 node
type NodeFloat64 struct {
	Value float64
	Left  *NodeFloat64
	Right *NodeFloat64
	Red   bool
	Count int
}

// IteratorCallbackFloat64 iterator
type IteratorCallbackFloat64 func(v float64) bool

// NewFloat64 construct new llrb
func NewFloat64() *LLRBFloat64 {
	return &LLRBFloat64{}
}

// NewNodeFloat64 construct new node
func NewNodeFloat64(v float64) *NodeFloat64 {
	return &NodeFloat64{
		Value: v,
		Red:   true,
		Count: 1,
	}
}

// Len returns number of elements in tree
func (llrb LLRBFloat64) Len() int {
	return llrb.Root.Len()
}

// Insert an element
func (llrb *LLRBFloat64) Insert(v float64) {
	n := NewNodeFloat64(v)
	llrb.Root = llrb.Root.insert(n)
	llrb.Root.Red = false
}

// Delete an element
func (llrb *LLRBFloat64) Delete(v float64) {
	llrb.Root = llrb.Root.delete(v)
	llrb.Root.Red = false
}

// Min element
func (llrb LLRBFloat64) Min() float64 {
	min := llrb.Root.Min()
	return min.Value
}

// Max element
func (llrb LLRBFloat64) Max() float64 {
	max := llrb.Root.Max()
	return max.Value
}

// Search if element in tree
func (llrb LLRBFloat64) Search(v float64) bool {
	return llrb.Root.Search(v)
}

// Get i-th smallest element
func (llrb LLRBFloat64) Get(i int) float64 {
	return llrb.Root.Get(i).Value
}

// Rank of v in tree
func (llrb LLRBFloat64) Rank(v float64) int {
	return llrb.Root.Rank(v)
}

// IterateAsc iterates ascending
func (llrb LLRBFloat64) IterateAsc(cb IteratorCallbackFloat64) {
	llrb.Root.IterateAsc(cb)
}

// IterateDesc iterates ascending
func (llrb LLRBFloat64) IterateDesc(cb IteratorCallbackFloat64) {
	llrb.Root.IterateDesc(cb)
}

// Len returns number of elements under node inclusive
func (node *NodeFloat64) Len() int {
	if node == nil {
		return 0
	}
	return node.Count
}

// IsRed checks if node is red
func (node *NodeFloat64) IsRed() bool {
	if node == nil {
		return false
	}
	return node.Red
}

// Min returns min element
func (node *NodeFloat64) Min() *NodeFloat64 {
	if node.Left == nil {
		return node
	}
	return node.Left.Min()
}

// Max returns max element
func (node *NodeFloat64) Max() *NodeFloat64 {
	if node.Right == nil {
		return node
	}
	return node.Right.Max()
}

func (node *NodeFloat64) refreshCount() {
	node.Count = node.Left.Len() + node.Right.Len() + 1
}

func (node *NodeFloat64) rotateLeft() *NodeFloat64 {
	x := node.Right
	node.Right = x.Left
	x.Left = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeFloat64) rotateRight() *NodeFloat64 {
	x := node.Left
	node.Left = x.Right
	x.Right = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeFloat64) flipColors() {
	node.Red = !node.Red
	if node.Left != nil {
		node.Left.Red = !node.Left.Red
	}
	if node.Right != nil {
		node.Right.Red = !node.Right.Red
	}
}

func (node *NodeFloat64) insert(newNode *NodeFloat64) *NodeFloat64 {
	if node == nil {
		return newNode
	}

	cmp := newNode.Compare(node.Value)
	if cmp == 0 {
		return node
	} else if cmp < 0 {
		node.Left = node.Left.insert(newNode)
	} else {
		node.Right = node.Right.insert(newNode)
	}

	node.refreshCount()

	if node.Right.IsRed() && !node.Left.IsRed() {
		node = node.rotateLeft()
	}
	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

func (node *NodeFloat64) moveRedLeft() *NodeFloat64 {
	node.flipColors()
	if node.Right != nil && node.Right.Left.IsRed() {
		node.Right = node.Right.rotateRight()
		node = node.rotateLeft()
		node.flipColors()
	}
	return node
}

func (node *NodeFloat64) moveRedRight() *NodeFloat64 {
	node.flipColors()
	if node.Left != nil && node.Left.Left.IsRed() {
		node = node.rotateRight()
		node.flipColors()
	}
	return node
}

func (node *NodeFloat64) delete(v float64) *NodeFloat64 {
	if node.Compare(v) > 0 {
		if node.Left == nil {
			return node
		}
		if !node.Left.IsRed() && !node.Left.Left.IsRed() {
			node = node.moveRedLeft()
		}
		node.Left = node.delete(v)
	} else {
		if node.Left.IsRed() {
			node = node.rotateRight()
		}
		if node.Compare(v) == 0 && node.Right == nil {
			return nil
		}
		if node.Right != nil {
			if !node.Right.IsRed() && !node.Right.Left.IsRed() {
				node = node.moveRedRight()
			}
			if node.Compare(v) == 0 {
				node.Value = node.Right.Min().Value
				node.Right = node.Right.deleteMin()
			} else {
				node.Right = node.Right.delete(v)
			}
		}
	}
	return node.fixUp()
}

func (node *NodeFloat64) deleteMin() *NodeFloat64 {
	if node.Left == nil {
		return nil
	}

	if !node.Left.IsRed() && !node.Left.Left.IsRed() {
		node = node.moveRedLeft()
	}

	node.Left = node.Left.deleteMin()

	return node.fixUp()
}

func (node *NodeFloat64) fixUp() *NodeFloat64 {
	node.refreshCount()

	if node.Right.IsRed() {
		node = node.rotateLeft()
	}

	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

// Search if v in tree
func (node *NodeFloat64) Search(v float64) bool {
	if node == nil {
		return false
	}

	cmp := node.Compare(v)
	if cmp == 0 {
		return true
	}
	if cmp < 0 {
		return node.Left.Search(v)
	}
	return node.Right.Search(v)
}

// Get i-th smallest value
func (node *NodeFloat64) Get(i int) *NodeFloat64 {
	r := node.Left.Len() + 1
	if i == r {
		return node
	}
	if i < r {
		return node.Left.Get(i)
	}
	return node.Right.Get(i - r)
}

// Rank of v in tree
func (node *NodeFloat64) Rank(v float64) int {
	if node == nil {
		return -1
	}

	r := node.Left.Len() + 1

	cmp := node.Compare(v)
	if cmp == 0 {
		return r
	}
	if cmp < 0 {
		return node.Left.Rank(v)
	}
	return node.Right.Rank(v) + r
}

// IterateAsc iterate ascending
func (node *NodeFloat64) IterateAsc(cb IteratorCallbackFloat64) bool {
	if node != nil {
		cont := node.Left.IterateAsc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Right.IterateAsc(cb)
	}
	return true
}

// IterateDesc iterate descending
func (node *NodeFloat64) IterateDesc(cb IteratorCallbackFloat64) bool {
	if node != nil {
		cont := node.Right.IterateDesc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Left.IterateDesc(cb)
	}
	return true
}

// LLRBSliceSliceFloat64 tree
type LLRBSliceSliceFloat64 struct {
	Root *NodeSliceSliceFloat64
}

// NodeSliceSliceFloat64 node
type NodeSliceSliceFloat64 struct {
	Value slice.SliceFloat64
	Left  *NodeSliceSliceFloat64
	Right *NodeSliceSliceFloat64
	Red   bool
	Count int
}

// IteratorCallbackSliceSliceFloat64 iterator
type IteratorCallbackSliceSliceFloat64 func(v slice.SliceFloat64) bool

// NewSliceSliceFloat64 construct new llrb
func NewSliceSliceFloat64() *LLRBSliceSliceFloat64 {
	return &LLRBSliceSliceFloat64{}
}

// NewNodeSliceSliceFloat64 construct new node
func NewNodeSliceSliceFloat64(v slice.SliceFloat64) *NodeSliceSliceFloat64 {
	return &NodeSliceSliceFloat64{
		Value: v,
		Red:   true,
		Count: 1,
	}
}

// Len returns number of elements in tree
func (llrb LLRBSliceSliceFloat64) Len() int {
	return llrb.Root.Len()
}

// Insert an element
func (llrb *LLRBSliceSliceFloat64) Insert(v slice.SliceFloat64) {
	n := NewNodeSliceSliceFloat64(v)
	llrb.Root = llrb.Root.insert(n)
	llrb.Root.Red = false
}

// Delete an element
func (llrb *LLRBSliceSliceFloat64) Delete(v slice.SliceFloat64) {
	llrb.Root = llrb.Root.delete(v)
	llrb.Root.Red = false
}

// Min element
func (llrb LLRBSliceSliceFloat64) Min() slice.SliceFloat64 {
	min := llrb.Root.Min()
	return min.Value
}

// Max element
func (llrb LLRBSliceSliceFloat64) Max() slice.SliceFloat64 {
	max := llrb.Root.Max()
	return max.Value
}

// Search if element in tree
func (llrb LLRBSliceSliceFloat64) Search(v slice.SliceFloat64) bool {
	return llrb.Root.Search(v)
}

// Get i-th smallest element
func (llrb LLRBSliceSliceFloat64) Get(i int) slice.SliceFloat64 {
	return llrb.Root.Get(i).Value
}

// Rank of v in tree
func (llrb LLRBSliceSliceFloat64) Rank(v slice.SliceFloat64) int {
	return llrb.Root.Rank(v)
}

// IterateAsc iterates ascending
func (llrb LLRBSliceSliceFloat64) IterateAsc(cb IteratorCallbackSliceSliceFloat64) {
	llrb.Root.IterateAsc(cb)
}

// IterateDesc iterates ascending
func (llrb LLRBSliceSliceFloat64) IterateDesc(cb IteratorCallbackSliceSliceFloat64) {
	llrb.Root.IterateDesc(cb)
}

// Len returns number of elements under node inclusive
func (node *NodeSliceSliceFloat64) Len() int {
	if node == nil {
		return 0
	}
	return node.Count
}

// IsRed checks if node is red
func (node *NodeSliceSliceFloat64) IsRed() bool {
	if node == nil {
		return false
	}
	return node.Red
}

// Min returns min element
func (node *NodeSliceSliceFloat64) Min() *NodeSliceSliceFloat64 {
	if node.Left == nil {
		return node
	}
	return node.Left.Min()
}

// Max returns max element
func (node *NodeSliceSliceFloat64) Max() *NodeSliceSliceFloat64 {
	if node.Right == nil {
		return node
	}
	return node.Right.Max()
}

func (node *NodeSliceSliceFloat64) refreshCount() {
	node.Count = node.Left.Len() + node.Right.Len() + 1
}

func (node *NodeSliceSliceFloat64) rotateLeft() *NodeSliceSliceFloat64 {
	x := node.Right
	node.Right = x.Left
	x.Left = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeSliceSliceFloat64) rotateRight() *NodeSliceSliceFloat64 {
	x := node.Left
	node.Left = x.Right
	x.Right = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeSliceSliceFloat64) flipColors() {
	node.Red = !node.Red
	if node.Left != nil {
		node.Left.Red = !node.Left.Red
	}
	if node.Right != nil {
		node.Right.Red = !node.Right.Red
	}
}

func (node *NodeSliceSliceFloat64) insert(newNode *NodeSliceSliceFloat64) *NodeSliceSliceFloat64 {
	if node == nil {
		return newNode
	}

	cmp := newNode.Compare(node.Value)
	if cmp == 0 {
		return node
	} else if cmp < 0 {
		node.Left = node.Left.insert(newNode)
	} else {
		node.Right = node.Right.insert(newNode)
	}

	node.refreshCount()

	if node.Right.IsRed() && !node.Left.IsRed() {
		node = node.rotateLeft()
	}
	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

func (node *NodeSliceSliceFloat64) moveRedLeft() *NodeSliceSliceFloat64 {
	node.flipColors()
	if node.Right != nil && node.Right.Left.IsRed() {
		node.Right = node.Right.rotateRight()
		node = node.rotateLeft()
		node.flipColors()
	}
	return node
}

func (node *NodeSliceSliceFloat64) moveRedRight() *NodeSliceSliceFloat64 {
	node.flipColors()
	if node.Left != nil && node.Left.Left.IsRed() {
		node = node.rotateRight()
		node.flipColors()
	}
	return node
}

func (node *NodeSliceSliceFloat64) delete(v slice.SliceFloat64) *NodeSliceSliceFloat64 {
	if node.Compare(v) > 0 {
		if node.Left == nil {
			return node
		}
		if !node.Left.IsRed() && !node.Left.Left.IsRed() {
			node = node.moveRedLeft()
		}
		node.Left = node.delete(v)
	} else {
		if node.Left.IsRed() {
			node = node.rotateRight()
		}
		if node.Compare(v) == 0 && node.Right == nil {
			return nil
		}
		if node.Right != nil {
			if !node.Right.IsRed() && !node.Right.Left.IsRed() {
				node = node.moveRedRight()
			}
			if node.Compare(v) == 0 {
				node.Value = node.Right.Min().Value
				node.Right = node.Right.deleteMin()
			} else {
				node.Right = node.Right.delete(v)
			}
		}
	}
	return node.fixUp()
}

func (node *NodeSliceSliceFloat64) deleteMin() *NodeSliceSliceFloat64 {
	if node.Left == nil {
		return nil
	}

	if !node.Left.IsRed() && !node.Left.Left.IsRed() {
		node = node.moveRedLeft()
	}

	node.Left = node.Left.deleteMin()

	return node.fixUp()
}

func (node *NodeSliceSliceFloat64) fixUp() *NodeSliceSliceFloat64 {
	node.refreshCount()

	if node.Right.IsRed() {
		node = node.rotateLeft()
	}

	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

// Search if v in tree
func (node *NodeSliceSliceFloat64) Search(v slice.SliceFloat64) bool {
	if node == nil {
		return false
	}

	cmp := node.Compare(v)
	if cmp == 0 {
		return true
	}
	if cmp < 0 {
		return node.Left.Search(v)
	}
	return node.Right.Search(v)
}

// Get i-th smallest value
func (node *NodeSliceSliceFloat64) Get(i int) *NodeSliceSliceFloat64 {
	r := node.Left.Len() + 1
	if i == r {
		return node
	}
	if i < r {
		return node.Left.Get(i)
	}
	return node.Right.Get(i - r)
}

// Rank of v in tree
func (node *NodeSliceSliceFloat64) Rank(v slice.SliceFloat64) int {
	if node == nil {
		return -1
	}

	r := node.Left.Len() + 1

	cmp := node.Compare(v)
	if cmp == 0 {
		return r
	}
	if cmp < 0 {
		return node.Left.Rank(v)
	}
	return node.Right.Rank(v) + r
}

// IterateAsc iterate ascending
func (node *NodeSliceSliceFloat64) IterateAsc(cb IteratorCallbackSliceSliceFloat64) bool {
	if node != nil {
		cont := node.Left.IterateAsc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Right.IterateAsc(cb)
	}
	return true
}

// IterateDesc iterate descending
func (node *NodeSliceSliceFloat64) IterateDesc(cb IteratorCallbackSliceSliceFloat64) bool {
	if node != nil {
		cont := node.Right.IterateDesc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Left.IterateDesc(cb)
	}
	return true
}

// LLRBString tree
type LLRBString struct {
	Root *NodeString
}

// NodeString node
type NodeString struct {
	Value string
	Left  *NodeString
	Right *NodeString
	Red   bool
	Count int
}

// IteratorCallbackString iterator
type IteratorCallbackString func(v string) bool

// NewString construct new llrb
func NewString() *LLRBString {
	return &LLRBString{}
}

// NewNodeString construct new node
func NewNodeString(v string) *NodeString {
	return &NodeString{
		Value: v,
		Red:   true,
		Count: 1,
	}
}

// Len returns number of elements in tree
func (llrb LLRBString) Len() int {
	return llrb.Root.Len()
}

// Insert an element
func (llrb *LLRBString) Insert(v string) {
	n := NewNodeString(v)
	llrb.Root = llrb.Root.insert(n)
	llrb.Root.Red = false
}

// Delete an element
func (llrb *LLRBString) Delete(v string) {
	llrb.Root = llrb.Root.delete(v)
	llrb.Root.Red = false
}

// Min element
func (llrb LLRBString) Min() string {
	min := llrb.Root.Min()
	return min.Value
}

// Max element
func (llrb LLRBString) Max() string {
	max := llrb.Root.Max()
	return max.Value
}

// Search if element in tree
func (llrb LLRBString) Search(v string) bool {
	return llrb.Root.Search(v)
}

// Get i-th smallest element
func (llrb LLRBString) Get(i int) string {
	return llrb.Root.Get(i).Value
}

// Rank of v in tree
func (llrb LLRBString) Rank(v string) int {
	return llrb.Root.Rank(v)
}

// IterateAsc iterates ascending
func (llrb LLRBString) IterateAsc(cb IteratorCallbackString) {
	llrb.Root.IterateAsc(cb)
}

// IterateDesc iterates ascending
func (llrb LLRBString) IterateDesc(cb IteratorCallbackString) {
	llrb.Root.IterateDesc(cb)
}

// Len returns number of elements under node inclusive
func (node *NodeString) Len() int {
	if node == nil {
		return 0
	}
	return node.Count
}

// IsRed checks if node is red
func (node *NodeString) IsRed() bool {
	if node == nil {
		return false
	}
	return node.Red
}

// Min returns min element
func (node *NodeString) Min() *NodeString {
	if node.Left == nil {
		return node
	}
	return node.Left.Min()
}

// Max returns max element
func (node *NodeString) Max() *NodeString {
	if node.Right == nil {
		return node
	}
	return node.Right.Max()
}

func (node *NodeString) refreshCount() {
	node.Count = node.Left.Len() + node.Right.Len() + 1
}

func (node *NodeString) rotateLeft() *NodeString {
	x := node.Right
	node.Right = x.Left
	x.Left = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeString) rotateRight() *NodeString {
	x := node.Left
	node.Left = x.Right
	x.Right = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeString) flipColors() {
	node.Red = !node.Red
	if node.Left != nil {
		node.Left.Red = !node.Left.Red
	}
	if node.Right != nil {
		node.Right.Red = !node.Right.Red
	}
}

func (node *NodeString) insert(newNode *NodeString) *NodeString {
	if node == nil {
		return newNode
	}

	cmp := newNode.Compare(node.Value)
	if cmp == 0 {
		return node
	} else if cmp < 0 {
		node.Left = node.Left.insert(newNode)
	} else {
		node.Right = node.Right.insert(newNode)
	}

	node.refreshCount()

	if node.Right.IsRed() && !node.Left.IsRed() {
		node = node.rotateLeft()
	}
	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

func (node *NodeString) moveRedLeft() *NodeString {
	node.flipColors()
	if node.Right != nil && node.Right.Left.IsRed() {
		node.Right = node.Right.rotateRight()
		node = node.rotateLeft()
		node.flipColors()
	}
	return node
}

func (node *NodeString) moveRedRight() *NodeString {
	node.flipColors()
	if node.Left != nil && node.Left.Left.IsRed() {
		node = node.rotateRight()
		node.flipColors()
	}
	return node
}

func (node *NodeString) delete(v string) *NodeString {
	if node.Compare(v) > 0 {
		if node.Left == nil {
			return node
		}
		if !node.Left.IsRed() && !node.Left.Left.IsRed() {
			node = node.moveRedLeft()
		}
		node.Left = node.delete(v)
	} else {
		if node.Left.IsRed() {
			node = node.rotateRight()
		}
		if node.Compare(v) == 0 && node.Right == nil {
			return nil
		}
		if node.Right != nil {
			if !node.Right.IsRed() && !node.Right.Left.IsRed() {
				node = node.moveRedRight()
			}
			if node.Compare(v) == 0 {
				node.Value = node.Right.Min().Value
				node.Right = node.Right.deleteMin()
			} else {
				node.Right = node.Right.delete(v)
			}
		}
	}
	return node.fixUp()
}

func (node *NodeString) deleteMin() *NodeString {
	if node.Left == nil {
		return nil
	}

	if !node.Left.IsRed() && !node.Left.Left.IsRed() {
		node = node.moveRedLeft()
	}

	node.Left = node.Left.deleteMin()

	return node.fixUp()
}

func (node *NodeString) fixUp() *NodeString {
	node.refreshCount()

	if node.Right.IsRed() {
		node = node.rotateLeft()
	}

	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

// Search if v in tree
func (node *NodeString) Search(v string) bool {
	if node == nil {
		return false
	}

	cmp := node.Compare(v)
	if cmp == 0 {
		return true
	}
	if cmp < 0 {
		return node.Left.Search(v)
	}
	return node.Right.Search(v)
}

// Get i-th smallest value
func (node *NodeString) Get(i int) *NodeString {
	r := node.Left.Len() + 1
	if i == r {
		return node
	}
	if i < r {
		return node.Left.Get(i)
	}
	return node.Right.Get(i - r)
}

// Rank of v in tree
func (node *NodeString) Rank(v string) int {
	if node == nil {
		return -1
	}

	r := node.Left.Len() + 1

	cmp := node.Compare(v)
	if cmp == 0 {
		return r
	}
	if cmp < 0 {
		return node.Left.Rank(v)
	}
	return node.Right.Rank(v) + r
}

// IterateAsc iterate ascending
func (node *NodeString) IterateAsc(cb IteratorCallbackString) bool {
	if node != nil {
		cont := node.Left.IterateAsc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Right.IterateAsc(cb)
	}
	return true
}

// IterateDesc iterate descending
func (node *NodeString) IterateDesc(cb IteratorCallbackString) bool {
	if node != nil {
		cont := node.Right.IterateDesc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Left.IterateDesc(cb)
	}
	return true
}

// LLRBSliceSliceString tree
type LLRBSliceSliceString struct {
	Root *NodeSliceSliceString
}

// NodeSliceSliceString node
type NodeSliceSliceString struct {
	Value slice.SliceString
	Left  *NodeSliceSliceString
	Right *NodeSliceSliceString
	Red   bool
	Count int
}

// IteratorCallbackSliceSliceString iterator
type IteratorCallbackSliceSliceString func(v slice.SliceString) bool

// NewSliceSliceString construct new llrb
func NewSliceSliceString() *LLRBSliceSliceString {
	return &LLRBSliceSliceString{}
}

// NewNodeSliceSliceString construct new node
func NewNodeSliceSliceString(v slice.SliceString) *NodeSliceSliceString {
	return &NodeSliceSliceString{
		Value: v,
		Red:   true,
		Count: 1,
	}
}

// Len returns number of elements in tree
func (llrb LLRBSliceSliceString) Len() int {
	return llrb.Root.Len()
}

// Insert an element
func (llrb *LLRBSliceSliceString) Insert(v slice.SliceString) {
	n := NewNodeSliceSliceString(v)
	llrb.Root = llrb.Root.insert(n)
	llrb.Root.Red = false
}

// Delete an element
func (llrb *LLRBSliceSliceString) Delete(v slice.SliceString) {
	llrb.Root = llrb.Root.delete(v)
	llrb.Root.Red = false
}

// Min element
func (llrb LLRBSliceSliceString) Min() slice.SliceString {
	min := llrb.Root.Min()
	return min.Value
}

// Max element
func (llrb LLRBSliceSliceString) Max() slice.SliceString {
	max := llrb.Root.Max()
	return max.Value
}

// Search if element in tree
func (llrb LLRBSliceSliceString) Search(v slice.SliceString) bool {
	return llrb.Root.Search(v)
}

// Get i-th smallest element
func (llrb LLRBSliceSliceString) Get(i int) slice.SliceString {
	return llrb.Root.Get(i).Value
}

// Rank of v in tree
func (llrb LLRBSliceSliceString) Rank(v slice.SliceString) int {
	return llrb.Root.Rank(v)
}

// IterateAsc iterates ascending
func (llrb LLRBSliceSliceString) IterateAsc(cb IteratorCallbackSliceSliceString) {
	llrb.Root.IterateAsc(cb)
}

// IterateDesc iterates ascending
func (llrb LLRBSliceSliceString) IterateDesc(cb IteratorCallbackSliceSliceString) {
	llrb.Root.IterateDesc(cb)
}

// Len returns number of elements under node inclusive
func (node *NodeSliceSliceString) Len() int {
	if node == nil {
		return 0
	}
	return node.Count
}

// IsRed checks if node is red
func (node *NodeSliceSliceString) IsRed() bool {
	if node == nil {
		return false
	}
	return node.Red
}

// Min returns min element
func (node *NodeSliceSliceString) Min() *NodeSliceSliceString {
	if node.Left == nil {
		return node
	}
	return node.Left.Min()
}

// Max returns max element
func (node *NodeSliceSliceString) Max() *NodeSliceSliceString {
	if node.Right == nil {
		return node
	}
	return node.Right.Max()
}

func (node *NodeSliceSliceString) refreshCount() {
	node.Count = node.Left.Len() + node.Right.Len() + 1
}

func (node *NodeSliceSliceString) rotateLeft() *NodeSliceSliceString {
	x := node.Right
	node.Right = x.Left
	x.Left = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeSliceSliceString) rotateRight() *NodeSliceSliceString {
	x := node.Left
	node.Left = x.Right
	x.Right = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeSliceSliceString) flipColors() {
	node.Red = !node.Red
	if node.Left != nil {
		node.Left.Red = !node.Left.Red
	}
	if node.Right != nil {
		node.Right.Red = !node.Right.Red
	}
}

func (node *NodeSliceSliceString) insert(newNode *NodeSliceSliceString) *NodeSliceSliceString {
	if node == nil {
		return newNode
	}

	cmp := newNode.Compare(node.Value)
	if cmp == 0 {
		return node
	} else if cmp < 0 {
		node.Left = node.Left.insert(newNode)
	} else {
		node.Right = node.Right.insert(newNode)
	}

	node.refreshCount()

	if node.Right.IsRed() && !node.Left.IsRed() {
		node = node.rotateLeft()
	}
	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

func (node *NodeSliceSliceString) moveRedLeft() *NodeSliceSliceString {
	node.flipColors()
	if node.Right != nil && node.Right.Left.IsRed() {
		node.Right = node.Right.rotateRight()
		node = node.rotateLeft()
		node.flipColors()
	}
	return node
}

func (node *NodeSliceSliceString) moveRedRight() *NodeSliceSliceString {
	node.flipColors()
	if node.Left != nil && node.Left.Left.IsRed() {
		node = node.rotateRight()
		node.flipColors()
	}
	return node
}

func (node *NodeSliceSliceString) delete(v slice.SliceString) *NodeSliceSliceString {
	if node.Compare(v) > 0 {
		if node.Left == nil {
			return node
		}
		if !node.Left.IsRed() && !node.Left.Left.IsRed() {
			node = node.moveRedLeft()
		}
		node.Left = node.delete(v)
	} else {
		if node.Left.IsRed() {
			node = node.rotateRight()
		}
		if node.Compare(v) == 0 && node.Right == nil {
			return nil
		}
		if node.Right != nil {
			if !node.Right.IsRed() && !node.Right.Left.IsRed() {
				node = node.moveRedRight()
			}
			if node.Compare(v) == 0 {
				node.Value = node.Right.Min().Value
				node.Right = node.Right.deleteMin()
			} else {
				node.Right = node.Right.delete(v)
			}
		}
	}
	return node.fixUp()
}

func (node *NodeSliceSliceString) deleteMin() *NodeSliceSliceString {
	if node.Left == nil {
		return nil
	}

	if !node.Left.IsRed() && !node.Left.Left.IsRed() {
		node = node.moveRedLeft()
	}

	node.Left = node.Left.deleteMin()

	return node.fixUp()
}

func (node *NodeSliceSliceString) fixUp() *NodeSliceSliceString {
	node.refreshCount()

	if node.Right.IsRed() {
		node = node.rotateLeft()
	}

	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

// Search if v in tree
func (node *NodeSliceSliceString) Search(v slice.SliceString) bool {
	if node == nil {
		return false
	}

	cmp := node.Compare(v)
	if cmp == 0 {
		return true
	}
	if cmp < 0 {
		return node.Left.Search(v)
	}
	return node.Right.Search(v)
}

// Get i-th smallest value
func (node *NodeSliceSliceString) Get(i int) *NodeSliceSliceString {
	r := node.Left.Len() + 1
	if i == r {
		return node
	}
	if i < r {
		return node.Left.Get(i)
	}
	return node.Right.Get(i - r)
}

// Rank of v in tree
func (node *NodeSliceSliceString) Rank(v slice.SliceString) int {
	if node == nil {
		return -1
	}

	r := node.Left.Len() + 1

	cmp := node.Compare(v)
	if cmp == 0 {
		return r
	}
	if cmp < 0 {
		return node.Left.Rank(v)
	}
	return node.Right.Rank(v) + r
}

// IterateAsc iterate ascending
func (node *NodeSliceSliceString) IterateAsc(cb IteratorCallbackSliceSliceString) bool {
	if node != nil {
		cont := node.Left.IterateAsc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Right.IterateAsc(cb)
	}
	return true
}

// IterateDesc iterate descending
func (node *NodeSliceSliceString) IterateDesc(cb IteratorCallbackSliceSliceString) bool {
	if node != nil {
		cont := node.Right.IterateDesc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Left.IterateDesc(cb)
	}
	return true
}

// LLRBByte tree
type LLRBByte struct {
	Root *NodeByte
}

// NodeByte node
type NodeByte struct {
	Value byte
	Left  *NodeByte
	Right *NodeByte
	Red   bool
	Count int
}

// IteratorCallbackByte iterator
type IteratorCallbackByte func(v byte) bool

// NewByte construct new llrb
func NewByte() *LLRBByte {
	return &LLRBByte{}
}

// NewNodeByte construct new node
func NewNodeByte(v byte) *NodeByte {
	return &NodeByte{
		Value: v,
		Red:   true,
		Count: 1,
	}
}

// Len returns number of elements in tree
func (llrb LLRBByte) Len() int {
	return llrb.Root.Len()
}

// Insert an element
func (llrb *LLRBByte) Insert(v byte) {
	n := NewNodeByte(v)
	llrb.Root = llrb.Root.insert(n)
	llrb.Root.Red = false
}

// Delete an element
func (llrb *LLRBByte) Delete(v byte) {
	llrb.Root = llrb.Root.delete(v)
	llrb.Root.Red = false
}

// Min element
func (llrb LLRBByte) Min() byte {
	min := llrb.Root.Min()
	return min.Value
}

// Max element
func (llrb LLRBByte) Max() byte {
	max := llrb.Root.Max()
	return max.Value
}

// Search if element in tree
func (llrb LLRBByte) Search(v byte) bool {
	return llrb.Root.Search(v)
}

// Get i-th smallest element
func (llrb LLRBByte) Get(i int) byte {
	return llrb.Root.Get(i).Value
}

// Rank of v in tree
func (llrb LLRBByte) Rank(v byte) int {
	return llrb.Root.Rank(v)
}

// IterateAsc iterates ascending
func (llrb LLRBByte) IterateAsc(cb IteratorCallbackByte) {
	llrb.Root.IterateAsc(cb)
}

// IterateDesc iterates ascending
func (llrb LLRBByte) IterateDesc(cb IteratorCallbackByte) {
	llrb.Root.IterateDesc(cb)
}

// Len returns number of elements under node inclusive
func (node *NodeByte) Len() int {
	if node == nil {
		return 0
	}
	return node.Count
}

// IsRed checks if node is red
func (node *NodeByte) IsRed() bool {
	if node == nil {
		return false
	}
	return node.Red
}

// Min returns min element
func (node *NodeByte) Min() *NodeByte {
	if node.Left == nil {
		return node
	}
	return node.Left.Min()
}

// Max returns max element
func (node *NodeByte) Max() *NodeByte {
	if node.Right == nil {
		return node
	}
	return node.Right.Max()
}

func (node *NodeByte) refreshCount() {
	node.Count = node.Left.Len() + node.Right.Len() + 1
}

func (node *NodeByte) rotateLeft() *NodeByte {
	x := node.Right
	node.Right = x.Left
	x.Left = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeByte) rotateRight() *NodeByte {
	x := node.Left
	node.Left = x.Right
	x.Right = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeByte) flipColors() {
	node.Red = !node.Red
	if node.Left != nil {
		node.Left.Red = !node.Left.Red
	}
	if node.Right != nil {
		node.Right.Red = !node.Right.Red
	}
}

func (node *NodeByte) insert(newNode *NodeByte) *NodeByte {
	if node == nil {
		return newNode
	}

	cmp := newNode.Compare(node.Value)
	if cmp == 0 {
		return node
	} else if cmp < 0 {
		node.Left = node.Left.insert(newNode)
	} else {
		node.Right = node.Right.insert(newNode)
	}

	node.refreshCount()

	if node.Right.IsRed() && !node.Left.IsRed() {
		node = node.rotateLeft()
	}
	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

func (node *NodeByte) moveRedLeft() *NodeByte {
	node.flipColors()
	if node.Right != nil && node.Right.Left.IsRed() {
		node.Right = node.Right.rotateRight()
		node = node.rotateLeft()
		node.flipColors()
	}
	return node
}

func (node *NodeByte) moveRedRight() *NodeByte {
	node.flipColors()
	if node.Left != nil && node.Left.Left.IsRed() {
		node = node.rotateRight()
		node.flipColors()
	}
	return node
}

func (node *NodeByte) delete(v byte) *NodeByte {
	if node.Compare(v) > 0 {
		if node.Left == nil {
			return node
		}
		if !node.Left.IsRed() && !node.Left.Left.IsRed() {
			node = node.moveRedLeft()
		}
		node.Left = node.delete(v)
	} else {
		if node.Left.IsRed() {
			node = node.rotateRight()
		}
		if node.Compare(v) == 0 && node.Right == nil {
			return nil
		}
		if node.Right != nil {
			if !node.Right.IsRed() && !node.Right.Left.IsRed() {
				node = node.moveRedRight()
			}
			if node.Compare(v) == 0 {
				node.Value = node.Right.Min().Value
				node.Right = node.Right.deleteMin()
			} else {
				node.Right = node.Right.delete(v)
			}
		}
	}
	return node.fixUp()
}

func (node *NodeByte) deleteMin() *NodeByte {
	if node.Left == nil {
		return nil
	}

	if !node.Left.IsRed() && !node.Left.Left.IsRed() {
		node = node.moveRedLeft()
	}

	node.Left = node.Left.deleteMin()

	return node.fixUp()
}

func (node *NodeByte) fixUp() *NodeByte {
	node.refreshCount()

	if node.Right.IsRed() {
		node = node.rotateLeft()
	}

	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

// Search if v in tree
func (node *NodeByte) Search(v byte) bool {
	if node == nil {
		return false
	}

	cmp := node.Compare(v)
	if cmp == 0 {
		return true
	}
	if cmp < 0 {
		return node.Left.Search(v)
	}
	return node.Right.Search(v)
}

// Get i-th smallest value
func (node *NodeByte) Get(i int) *NodeByte {
	r := node.Left.Len() + 1
	if i == r {
		return node
	}
	if i < r {
		return node.Left.Get(i)
	}
	return node.Right.Get(i - r)
}

// Rank of v in tree
func (node *NodeByte) Rank(v byte) int {
	if node == nil {
		return -1
	}

	r := node.Left.Len() + 1

	cmp := node.Compare(v)
	if cmp == 0 {
		return r
	}
	if cmp < 0 {
		return node.Left.Rank(v)
	}
	return node.Right.Rank(v) + r
}

// IterateAsc iterate ascending
func (node *NodeByte) IterateAsc(cb IteratorCallbackByte) bool {
	if node != nil {
		cont := node.Left.IterateAsc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Right.IterateAsc(cb)
	}
	return true
}

// IterateDesc iterate descending
func (node *NodeByte) IterateDesc(cb IteratorCallbackByte) bool {
	if node != nil {
		cont := node.Right.IterateDesc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Left.IterateDesc(cb)
	}
	return true
}

// LLRBSliceSliceByte tree
type LLRBSliceSliceByte struct {
	Root *NodeSliceSliceByte
}

// NodeSliceSliceByte node
type NodeSliceSliceByte struct {
	Value slice.SliceByte
	Left  *NodeSliceSliceByte
	Right *NodeSliceSliceByte
	Red   bool
	Count int
}

// IteratorCallbackSliceSliceByte iterator
type IteratorCallbackSliceSliceByte func(v slice.SliceByte) bool

// NewSliceSliceByte construct new llrb
func NewSliceSliceByte() *LLRBSliceSliceByte {
	return &LLRBSliceSliceByte{}
}

// NewNodeSliceSliceByte construct new node
func NewNodeSliceSliceByte(v slice.SliceByte) *NodeSliceSliceByte {
	return &NodeSliceSliceByte{
		Value: v,
		Red:   true,
		Count: 1,
	}
}

// Len returns number of elements in tree
func (llrb LLRBSliceSliceByte) Len() int {
	return llrb.Root.Len()
}

// Insert an element
func (llrb *LLRBSliceSliceByte) Insert(v slice.SliceByte) {
	n := NewNodeSliceSliceByte(v)
	llrb.Root = llrb.Root.insert(n)
	llrb.Root.Red = false
}

// Delete an element
func (llrb *LLRBSliceSliceByte) Delete(v slice.SliceByte) {
	llrb.Root = llrb.Root.delete(v)
	llrb.Root.Red = false
}

// Min element
func (llrb LLRBSliceSliceByte) Min() slice.SliceByte {
	min := llrb.Root.Min()
	return min.Value
}

// Max element
func (llrb LLRBSliceSliceByte) Max() slice.SliceByte {
	max := llrb.Root.Max()
	return max.Value
}

// Search if element in tree
func (llrb LLRBSliceSliceByte) Search(v slice.SliceByte) bool {
	return llrb.Root.Search(v)
}

// Get i-th smallest element
func (llrb LLRBSliceSliceByte) Get(i int) slice.SliceByte {
	return llrb.Root.Get(i).Value
}

// Rank of v in tree
func (llrb LLRBSliceSliceByte) Rank(v slice.SliceByte) int {
	return llrb.Root.Rank(v)
}

// IterateAsc iterates ascending
func (llrb LLRBSliceSliceByte) IterateAsc(cb IteratorCallbackSliceSliceByte) {
	llrb.Root.IterateAsc(cb)
}

// IterateDesc iterates ascending
func (llrb LLRBSliceSliceByte) IterateDesc(cb IteratorCallbackSliceSliceByte) {
	llrb.Root.IterateDesc(cb)
}

// Len returns number of elements under node inclusive
func (node *NodeSliceSliceByte) Len() int {
	if node == nil {
		return 0
	}
	return node.Count
}

// IsRed checks if node is red
func (node *NodeSliceSliceByte) IsRed() bool {
	if node == nil {
		return false
	}
	return node.Red
}

// Min returns min element
func (node *NodeSliceSliceByte) Min() *NodeSliceSliceByte {
	if node.Left == nil {
		return node
	}
	return node.Left.Min()
}

// Max returns max element
func (node *NodeSliceSliceByte) Max() *NodeSliceSliceByte {
	if node.Right == nil {
		return node
	}
	return node.Right.Max()
}

func (node *NodeSliceSliceByte) refreshCount() {
	node.Count = node.Left.Len() + node.Right.Len() + 1
}

func (node *NodeSliceSliceByte) rotateLeft() *NodeSliceSliceByte {
	x := node.Right
	node.Right = x.Left
	x.Left = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeSliceSliceByte) rotateRight() *NodeSliceSliceByte {
	x := node.Left
	node.Left = x.Right
	x.Right = node
	x.Red = node.Red
	node.Red = true
	node.refreshCount()
	x.refreshCount()
	return x
}

func (node *NodeSliceSliceByte) flipColors() {
	node.Red = !node.Red
	if node.Left != nil {
		node.Left.Red = !node.Left.Red
	}
	if node.Right != nil {
		node.Right.Red = !node.Right.Red
	}
}

func (node *NodeSliceSliceByte) insert(newNode *NodeSliceSliceByte) *NodeSliceSliceByte {
	if node == nil {
		return newNode
	}

	cmp := newNode.Compare(node.Value)
	if cmp == 0 {
		return node
	} else if cmp < 0 {
		node.Left = node.Left.insert(newNode)
	} else {
		node.Right = node.Right.insert(newNode)
	}

	node.refreshCount()

	if node.Right.IsRed() && !node.Left.IsRed() {
		node = node.rotateLeft()
	}
	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

func (node *NodeSliceSliceByte) moveRedLeft() *NodeSliceSliceByte {
	node.flipColors()
	if node.Right != nil && node.Right.Left.IsRed() {
		node.Right = node.Right.rotateRight()
		node = node.rotateLeft()
		node.flipColors()
	}
	return node
}

func (node *NodeSliceSliceByte) moveRedRight() *NodeSliceSliceByte {
	node.flipColors()
	if node.Left != nil && node.Left.Left.IsRed() {
		node = node.rotateRight()
		node.flipColors()
	}
	return node
}

func (node *NodeSliceSliceByte) delete(v slice.SliceByte) *NodeSliceSliceByte {
	if node.Compare(v) > 0 {
		if node.Left == nil {
			return node
		}
		if !node.Left.IsRed() && !node.Left.Left.IsRed() {
			node = node.moveRedLeft()
		}
		node.Left = node.delete(v)
	} else {
		if node.Left.IsRed() {
			node = node.rotateRight()
		}
		if node.Compare(v) == 0 && node.Right == nil {
			return nil
		}
		if node.Right != nil {
			if !node.Right.IsRed() && !node.Right.Left.IsRed() {
				node = node.moveRedRight()
			}
			if node.Compare(v) == 0 {
				node.Value = node.Right.Min().Value
				node.Right = node.Right.deleteMin()
			} else {
				node.Right = node.Right.delete(v)
			}
		}
	}
	return node.fixUp()
}

func (node *NodeSliceSliceByte) deleteMin() *NodeSliceSliceByte {
	if node.Left == nil {
		return nil
	}

	if !node.Left.IsRed() && !node.Left.Left.IsRed() {
		node = node.moveRedLeft()
	}

	node.Left = node.Left.deleteMin()

	return node.fixUp()
}

func (node *NodeSliceSliceByte) fixUp() *NodeSliceSliceByte {
	node.refreshCount()

	if node.Right.IsRed() {
		node = node.rotateLeft()
	}

	if node.Left.IsRed() && node.Left.Left.IsRed() {
		node = node.rotateRight()
	}

	if node.Left.IsRed() && node.Right.IsRed() {
		node.flipColors()
	}

	return node
}

// Search if v in tree
func (node *NodeSliceSliceByte) Search(v slice.SliceByte) bool {
	if node == nil {
		return false
	}

	cmp := node.Compare(v)
	if cmp == 0 {
		return true
	}
	if cmp < 0 {
		return node.Left.Search(v)
	}
	return node.Right.Search(v)
}

// Get i-th smallest value
func (node *NodeSliceSliceByte) Get(i int) *NodeSliceSliceByte {
	r := node.Left.Len() + 1
	if i == r {
		return node
	}
	if i < r {
		return node.Left.Get(i)
	}
	return node.Right.Get(i - r)
}

// Rank of v in tree
func (node *NodeSliceSliceByte) Rank(v slice.SliceByte) int {
	if node == nil {
		return -1
	}

	r := node.Left.Len() + 1

	cmp := node.Compare(v)
	if cmp == 0 {
		return r
	}
	if cmp < 0 {
		return node.Left.Rank(v)
	}
	return node.Right.Rank(v) + r
}

// IterateAsc iterate ascending
func (node *NodeSliceSliceByte) IterateAsc(cb IteratorCallbackSliceSliceByte) bool {
	if node != nil {
		cont := node.Left.IterateAsc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Right.IterateAsc(cb)
	}
	return true
}

// IterateDesc iterate descending
func (node *NodeSliceSliceByte) IterateDesc(cb IteratorCallbackSliceSliceByte) bool {
	if node != nil {
		cont := node.Right.IterateDesc(cb)
		if !cont {
			return false
		}
		cont = cb(node.Value)
		if !cont {
			return false
		}
		return node.Left.IterateDesc(cb)
	}
	return true
}
