// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package queue

import "github.com/matematik7/codejam-go-v2/datastructures/slice"

type QueueBool struct {
	data  []bool
	front int
	back  int
}

func NewBool() QueueBool {
	return QueueBool{
		data:  make([]bool, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueBool) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueBool) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueBool) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueBool) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]bool, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueBool) Push(v bool) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueBool) PushFront(v bool) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueBool) Front() bool {
	return q.data[q.front]
}

func (q QueueBool) Back() bool {
	return q.data[q.dec(q.back)]
}

func (q *QueueBool) Pop() bool {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueBool) PopBack() bool {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueByte struct {
	data  []byte
	front int
	back  int
}

func NewByte() QueueByte {
	return QueueByte{
		data:  make([]byte, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueByte) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueByte) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueByte) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueByte) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]byte, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueByte) Push(v byte) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueByte) PushFront(v byte) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueByte) Front() byte {
	return q.data[q.front]
}

func (q QueueByte) Back() byte {
	return q.data[q.dec(q.back)]
}

func (q *QueueByte) Pop() byte {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueByte) PopBack() byte {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueComplex128 struct {
	data  []complex128
	front int
	back  int
}

func NewComplex128() QueueComplex128 {
	return QueueComplex128{
		data:  make([]complex128, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueComplex128) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueComplex128) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueComplex128) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueComplex128) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]complex128, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueComplex128) Push(v complex128) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueComplex128) PushFront(v complex128) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueComplex128) Front() complex128 {
	return q.data[q.front]
}

func (q QueueComplex128) Back() complex128 {
	return q.data[q.dec(q.back)]
}

func (q *QueueComplex128) Pop() complex128 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueComplex128) PopBack() complex128 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueComplex64 struct {
	data  []complex64
	front int
	back  int
}

func NewComplex64() QueueComplex64 {
	return QueueComplex64{
		data:  make([]complex64, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueComplex64) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueComplex64) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueComplex64) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueComplex64) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]complex64, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueComplex64) Push(v complex64) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueComplex64) PushFront(v complex64) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueComplex64) Front() complex64 {
	return q.data[q.front]
}

func (q QueueComplex64) Back() complex64 {
	return q.data[q.dec(q.back)]
}

func (q *QueueComplex64) Pop() complex64 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueComplex64) PopBack() complex64 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueError struct {
	data  []error
	front int
	back  int
}

func NewError() QueueError {
	return QueueError{
		data:  make([]error, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueError) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueError) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueError) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueError) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]error, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueError) Push(v error) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueError) PushFront(v error) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueError) Front() error {
	return q.data[q.front]
}

func (q QueueError) Back() error {
	return q.data[q.dec(q.back)]
}

func (q *QueueError) Pop() error {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueError) PopBack() error {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueFloat32 struct {
	data  []float32
	front int
	back  int
}

func NewFloat32() QueueFloat32 {
	return QueueFloat32{
		data:  make([]float32, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueFloat32) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueFloat32) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueFloat32) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueFloat32) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]float32, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueFloat32) Push(v float32) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueFloat32) PushFront(v float32) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueFloat32) Front() float32 {
	return q.data[q.front]
}

func (q QueueFloat32) Back() float32 {
	return q.data[q.dec(q.back)]
}

func (q *QueueFloat32) Pop() float32 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueFloat32) PopBack() float32 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueFloat64 struct {
	data  []float64
	front int
	back  int
}

func NewFloat64() QueueFloat64 {
	return QueueFloat64{
		data:  make([]float64, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueFloat64) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueFloat64) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueFloat64) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueFloat64) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]float64, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueFloat64) Push(v float64) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueFloat64) PushFront(v float64) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueFloat64) Front() float64 {
	return q.data[q.front]
}

func (q QueueFloat64) Back() float64 {
	return q.data[q.dec(q.back)]
}

func (q *QueueFloat64) Pop() float64 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueFloat64) PopBack() float64 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueInt struct {
	data  []int
	front int
	back  int
}

func NewInt() QueueInt {
	return QueueInt{
		data:  make([]int, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueInt) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueInt) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueInt) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueInt) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]int, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueInt) Push(v int) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueInt) PushFront(v int) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueInt) Front() int {
	return q.data[q.front]
}

func (q QueueInt) Back() int {
	return q.data[q.dec(q.back)]
}

func (q *QueueInt) Pop() int {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueInt) PopBack() int {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueInt16 struct {
	data  []int16
	front int
	back  int
}

func NewInt16() QueueInt16 {
	return QueueInt16{
		data:  make([]int16, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueInt16) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueInt16) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueInt16) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueInt16) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]int16, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueInt16) Push(v int16) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueInt16) PushFront(v int16) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueInt16) Front() int16 {
	return q.data[q.front]
}

func (q QueueInt16) Back() int16 {
	return q.data[q.dec(q.back)]
}

func (q *QueueInt16) Pop() int16 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueInt16) PopBack() int16 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueInt32 struct {
	data  []int32
	front int
	back  int
}

func NewInt32() QueueInt32 {
	return QueueInt32{
		data:  make([]int32, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueInt32) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueInt32) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueInt32) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueInt32) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]int32, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueInt32) Push(v int32) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueInt32) PushFront(v int32) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueInt32) Front() int32 {
	return q.data[q.front]
}

func (q QueueInt32) Back() int32 {
	return q.data[q.dec(q.back)]
}

func (q *QueueInt32) Pop() int32 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueInt32) PopBack() int32 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueInt64 struct {
	data  []int64
	front int
	back  int
}

func NewInt64() QueueInt64 {
	return QueueInt64{
		data:  make([]int64, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueInt64) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueInt64) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueInt64) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueInt64) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]int64, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueInt64) Push(v int64) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueInt64) PushFront(v int64) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueInt64) Front() int64 {
	return q.data[q.front]
}

func (q QueueInt64) Back() int64 {
	return q.data[q.dec(q.back)]
}

func (q *QueueInt64) Pop() int64 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueInt64) PopBack() int64 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueInt8 struct {
	data  []int8
	front int
	back  int
}

func NewInt8() QueueInt8 {
	return QueueInt8{
		data:  make([]int8, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueInt8) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueInt8) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueInt8) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueInt8) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]int8, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueInt8) Push(v int8) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueInt8) PushFront(v int8) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueInt8) Front() int8 {
	return q.data[q.front]
}

func (q QueueInt8) Back() int8 {
	return q.data[q.dec(q.back)]
}

func (q *QueueInt8) Pop() int8 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueInt8) PopBack() int8 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueRune struct {
	data  []rune
	front int
	back  int
}

func NewRune() QueueRune {
	return QueueRune{
		data:  make([]rune, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueRune) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueRune) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueRune) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueRune) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]rune, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueRune) Push(v rune) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueRune) PushFront(v rune) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueRune) Front() rune {
	return q.data[q.front]
}

func (q QueueRune) Back() rune {
	return q.data[q.dec(q.back)]
}

func (q *QueueRune) Pop() rune {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueRune) PopBack() rune {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueString struct {
	data  []string
	front int
	back  int
}

func NewString() QueueString {
	return QueueString{
		data:  make([]string, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueString) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueString) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueString) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueString) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]string, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueString) Push(v string) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueString) PushFront(v string) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueString) Front() string {
	return q.data[q.front]
}

func (q QueueString) Back() string {
	return q.data[q.dec(q.back)]
}

func (q *QueueString) Pop() string {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueString) PopBack() string {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueUint struct {
	data  []uint
	front int
	back  int
}

func NewUint() QueueUint {
	return QueueUint{
		data:  make([]uint, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueUint) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueUint) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueUint) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueUint) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]uint, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueUint) Push(v uint) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueUint) PushFront(v uint) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueUint) Front() uint {
	return q.data[q.front]
}

func (q QueueUint) Back() uint {
	return q.data[q.dec(q.back)]
}

func (q *QueueUint) Pop() uint {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueUint) PopBack() uint {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueUint16 struct {
	data  []uint16
	front int
	back  int
}

func NewUint16() QueueUint16 {
	return QueueUint16{
		data:  make([]uint16, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueUint16) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueUint16) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueUint16) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueUint16) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]uint16, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueUint16) Push(v uint16) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueUint16) PushFront(v uint16) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueUint16) Front() uint16 {
	return q.data[q.front]
}

func (q QueueUint16) Back() uint16 {
	return q.data[q.dec(q.back)]
}

func (q *QueueUint16) Pop() uint16 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueUint16) PopBack() uint16 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueUint32 struct {
	data  []uint32
	front int
	back  int
}

func NewUint32() QueueUint32 {
	return QueueUint32{
		data:  make([]uint32, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueUint32) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueUint32) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueUint32) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueUint32) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]uint32, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueUint32) Push(v uint32) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueUint32) PushFront(v uint32) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueUint32) Front() uint32 {
	return q.data[q.front]
}

func (q QueueUint32) Back() uint32 {
	return q.data[q.dec(q.back)]
}

func (q *QueueUint32) Pop() uint32 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueUint32) PopBack() uint32 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueUint64 struct {
	data  []uint64
	front int
	back  int
}

func NewUint64() QueueUint64 {
	return QueueUint64{
		data:  make([]uint64, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueUint64) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueUint64) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueUint64) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueUint64) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]uint64, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueUint64) Push(v uint64) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueUint64) PushFront(v uint64) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueUint64) Front() uint64 {
	return q.data[q.front]
}

func (q QueueUint64) Back() uint64 {
	return q.data[q.dec(q.back)]
}

func (q *QueueUint64) Pop() uint64 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueUint64) PopBack() uint64 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueUint8 struct {
	data  []uint8
	front int
	back  int
}

func NewUint8() QueueUint8 {
	return QueueUint8{
		data:  make([]uint8, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueUint8) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueUint8) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueUint8) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueUint8) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]uint8, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueUint8) Push(v uint8) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueUint8) PushFront(v uint8) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueUint8) Front() uint8 {
	return q.data[q.front]
}

func (q QueueUint8) Back() uint8 {
	return q.data[q.dec(q.back)]
}

func (q *QueueUint8) Pop() uint8 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueUint8) PopBack() uint8 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueUintptr struct {
	data  []uintptr
	front int
	back  int
}

func NewUintptr() QueueUintptr {
	return QueueUintptr{
		data:  make([]uintptr, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueUintptr) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueUintptr) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueUintptr) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueUintptr) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]uintptr, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueUintptr) Push(v uintptr) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueUintptr) PushFront(v uintptr) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueUintptr) Front() uintptr {
	return q.data[q.front]
}

func (q QueueUintptr) Back() uintptr {
	return q.data[q.dec(q.back)]
}

func (q *QueueUintptr) Pop() uintptr {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueUintptr) PopBack() uintptr {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueSliceSliceInt struct {
	data  []slice.SliceInt
	front int
	back  int
}

func NewSliceSliceInt() QueueSliceSliceInt {
	return QueueSliceSliceInt{
		data:  make([]slice.SliceInt, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueSliceSliceInt) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueSliceSliceInt) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueSliceSliceInt) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueSliceSliceInt) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]slice.SliceInt, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueSliceSliceInt) Push(v slice.SliceInt) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueSliceSliceInt) PushFront(v slice.SliceInt) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueSliceSliceInt) Front() slice.SliceInt {
	return q.data[q.front]
}

func (q QueueSliceSliceInt) Back() slice.SliceInt {
	return q.data[q.dec(q.back)]
}

func (q *QueueSliceSliceInt) Pop() slice.SliceInt {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueSliceSliceInt) PopBack() slice.SliceInt {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueSliceSliceSliceInt struct {
	data  []slice.SliceSliceInt
	front int
	back  int
}

func NewSliceSliceSliceInt() QueueSliceSliceSliceInt {
	return QueueSliceSliceSliceInt{
		data:  make([]slice.SliceSliceInt, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueSliceSliceSliceInt) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueSliceSliceSliceInt) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueSliceSliceSliceInt) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueSliceSliceSliceInt) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]slice.SliceSliceInt, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueSliceSliceSliceInt) Push(v slice.SliceSliceInt) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueSliceSliceSliceInt) PushFront(v slice.SliceSliceInt) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueSliceSliceSliceInt) Front() slice.SliceSliceInt {
	return q.data[q.front]
}

func (q QueueSliceSliceSliceInt) Back() slice.SliceSliceInt {
	return q.data[q.dec(q.back)]
}

func (q *QueueSliceSliceSliceInt) Pop() slice.SliceSliceInt {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueSliceSliceSliceInt) PopBack() slice.SliceSliceInt {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueSliceSliceFloat64 struct {
	data  []slice.SliceFloat64
	front int
	back  int
}

func NewSliceSliceFloat64() QueueSliceSliceFloat64 {
	return QueueSliceSliceFloat64{
		data:  make([]slice.SliceFloat64, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueSliceSliceFloat64) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueSliceSliceFloat64) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueSliceSliceFloat64) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueSliceSliceFloat64) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]slice.SliceFloat64, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueSliceSliceFloat64) Push(v slice.SliceFloat64) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueSliceSliceFloat64) PushFront(v slice.SliceFloat64) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueSliceSliceFloat64) Front() slice.SliceFloat64 {
	return q.data[q.front]
}

func (q QueueSliceSliceFloat64) Back() slice.SliceFloat64 {
	return q.data[q.dec(q.back)]
}

func (q *QueueSliceSliceFloat64) Pop() slice.SliceFloat64 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueSliceSliceFloat64) PopBack() slice.SliceFloat64 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}

type QueueSliceSliceSliceFloat64 struct {
	data  []slice.SliceSliceFloat64
	front int
	back  int
}

func NewSliceSliceSliceFloat64() QueueSliceSliceSliceFloat64 {
	return QueueSliceSliceSliceFloat64{
		data:  make([]slice.SliceSliceFloat64, 64),
		front: 0,
		back:  0,
	}
}

func (q *QueueSliceSliceSliceFloat64) inc(i int) int {
	return (i + 1) & (len(q.data) - 1)
}

func (q *QueueSliceSliceSliceFloat64) dec(i int) int {
	return (i - 1) & (len(q.data) - 1)
}

func (q QueueSliceSliceSliceFloat64) Len() int {
	return (q.back - q.front) & (len(q.data) - 1)
}

func (q *QueueSliceSliceSliceFloat64) growIfNeeded() {
	l := q.Len()
	if l < len(q.data)-1 {
		return
	}
	newData := make([]slice.SliceSliceFloat64, 4*len(q.data))
	if q.front < q.back {
		copy(newData, q.data[q.front:q.back])
	} else {
		n := copy(newData, q.data[q.front:])
		copy(newData[n:], q.data[:q.back])
	}
	q.data = newData
	q.front = 0
	q.back = l
}

func (q *QueueSliceSliceSliceFloat64) Push(v slice.SliceSliceFloat64) {
	q.growIfNeeded()
	q.data[q.back] = v
	q.back = q.inc(q.back)
}

func (q *QueueSliceSliceSliceFloat64) PushFront(v slice.SliceSliceFloat64) {
	q.growIfNeeded()
	q.front = q.dec(q.front)
	q.data[q.front] = v
}

func (q QueueSliceSliceSliceFloat64) Front() slice.SliceSliceFloat64 {
	return q.data[q.front]
}

func (q QueueSliceSliceSliceFloat64) Back() slice.SliceSliceFloat64 {
	return q.data[q.dec(q.back)]
}

func (q *QueueSliceSliceSliceFloat64) Pop() slice.SliceSliceFloat64 {
	v := q.Front()
	q.front = q.inc(q.front)
	return v
}

func (q *QueueSliceSliceSliceFloat64) PopBack() slice.SliceSliceFloat64 {
	q.back = q.dec(q.back)
	return q.data[q.back]
}
