// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package multiset

// MultiSetBool type
type MultiSetBool map[bool]int

// NewBool creates new set
func NewBool() MultiSetBool {
	return make(map[bool]int)
}

// Add adds elements
func (s MultiSetBool) Add(elements ...bool) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetBool) AddN(n int, elements ...bool) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetBool) Remove(elements ...bool) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetBool) RemoveN(n int, elements ...bool) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetBool) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetBool) Count(element bool) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetBool) Equal(other MultiSetBool) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetByte type
type MultiSetByte map[byte]int

// NewByte creates new set
func NewByte() MultiSetByte {
	return make(map[byte]int)
}

// Add adds elements
func (s MultiSetByte) Add(elements ...byte) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetByte) AddN(n int, elements ...byte) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetByte) Remove(elements ...byte) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetByte) RemoveN(n int, elements ...byte) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetByte) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetByte) Count(element byte) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetByte) Equal(other MultiSetByte) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetComplex128 type
type MultiSetComplex128 map[complex128]int

// NewComplex128 creates new set
func NewComplex128() MultiSetComplex128 {
	return make(map[complex128]int)
}

// Add adds elements
func (s MultiSetComplex128) Add(elements ...complex128) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetComplex128) AddN(n int, elements ...complex128) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetComplex128) Remove(elements ...complex128) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetComplex128) RemoveN(n int, elements ...complex128) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetComplex128) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetComplex128) Count(element complex128) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetComplex128) Equal(other MultiSetComplex128) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetComplex64 type
type MultiSetComplex64 map[complex64]int

// NewComplex64 creates new set
func NewComplex64() MultiSetComplex64 {
	return make(map[complex64]int)
}

// Add adds elements
func (s MultiSetComplex64) Add(elements ...complex64) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetComplex64) AddN(n int, elements ...complex64) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetComplex64) Remove(elements ...complex64) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetComplex64) RemoveN(n int, elements ...complex64) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetComplex64) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetComplex64) Count(element complex64) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetComplex64) Equal(other MultiSetComplex64) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetError type
type MultiSetError map[error]int

// NewError creates new set
func NewError() MultiSetError {
	return make(map[error]int)
}

// Add adds elements
func (s MultiSetError) Add(elements ...error) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetError) AddN(n int, elements ...error) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetError) Remove(elements ...error) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetError) RemoveN(n int, elements ...error) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetError) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetError) Count(element error) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetError) Equal(other MultiSetError) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetFloat32 type
type MultiSetFloat32 map[float32]int

// NewFloat32 creates new set
func NewFloat32() MultiSetFloat32 {
	return make(map[float32]int)
}

// Add adds elements
func (s MultiSetFloat32) Add(elements ...float32) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetFloat32) AddN(n int, elements ...float32) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetFloat32) Remove(elements ...float32) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetFloat32) RemoveN(n int, elements ...float32) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetFloat32) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetFloat32) Count(element float32) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetFloat32) Equal(other MultiSetFloat32) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetFloat64 type
type MultiSetFloat64 map[float64]int

// NewFloat64 creates new set
func NewFloat64() MultiSetFloat64 {
	return make(map[float64]int)
}

// Add adds elements
func (s MultiSetFloat64) Add(elements ...float64) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetFloat64) AddN(n int, elements ...float64) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetFloat64) Remove(elements ...float64) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetFloat64) RemoveN(n int, elements ...float64) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetFloat64) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetFloat64) Count(element float64) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetFloat64) Equal(other MultiSetFloat64) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetInt type
type MultiSetInt map[int]int

// NewInt creates new set
func NewInt() MultiSetInt {
	return make(map[int]int)
}

// Add adds elements
func (s MultiSetInt) Add(elements ...int) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetInt) AddN(n int, elements ...int) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetInt) Remove(elements ...int) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetInt) RemoveN(n int, elements ...int) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetInt) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetInt) Count(element int) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetInt) Equal(other MultiSetInt) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetInt16 type
type MultiSetInt16 map[int16]int

// NewInt16 creates new set
func NewInt16() MultiSetInt16 {
	return make(map[int16]int)
}

// Add adds elements
func (s MultiSetInt16) Add(elements ...int16) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetInt16) AddN(n int, elements ...int16) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetInt16) Remove(elements ...int16) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetInt16) RemoveN(n int, elements ...int16) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetInt16) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetInt16) Count(element int16) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetInt16) Equal(other MultiSetInt16) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetInt32 type
type MultiSetInt32 map[int32]int

// NewInt32 creates new set
func NewInt32() MultiSetInt32 {
	return make(map[int32]int)
}

// Add adds elements
func (s MultiSetInt32) Add(elements ...int32) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetInt32) AddN(n int, elements ...int32) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetInt32) Remove(elements ...int32) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetInt32) RemoveN(n int, elements ...int32) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetInt32) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetInt32) Count(element int32) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetInt32) Equal(other MultiSetInt32) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetInt64 type
type MultiSetInt64 map[int64]int

// NewInt64 creates new set
func NewInt64() MultiSetInt64 {
	return make(map[int64]int)
}

// Add adds elements
func (s MultiSetInt64) Add(elements ...int64) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetInt64) AddN(n int, elements ...int64) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetInt64) Remove(elements ...int64) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetInt64) RemoveN(n int, elements ...int64) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetInt64) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetInt64) Count(element int64) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetInt64) Equal(other MultiSetInt64) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetInt8 type
type MultiSetInt8 map[int8]int

// NewInt8 creates new set
func NewInt8() MultiSetInt8 {
	return make(map[int8]int)
}

// Add adds elements
func (s MultiSetInt8) Add(elements ...int8) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetInt8) AddN(n int, elements ...int8) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetInt8) Remove(elements ...int8) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetInt8) RemoveN(n int, elements ...int8) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetInt8) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetInt8) Count(element int8) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetInt8) Equal(other MultiSetInt8) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetRune type
type MultiSetRune map[rune]int

// NewRune creates new set
func NewRune() MultiSetRune {
	return make(map[rune]int)
}

// Add adds elements
func (s MultiSetRune) Add(elements ...rune) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetRune) AddN(n int, elements ...rune) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetRune) Remove(elements ...rune) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetRune) RemoveN(n int, elements ...rune) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetRune) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetRune) Count(element rune) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetRune) Equal(other MultiSetRune) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetString type
type MultiSetString map[string]int

// NewString creates new set
func NewString() MultiSetString {
	return make(map[string]int)
}

// Add adds elements
func (s MultiSetString) Add(elements ...string) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetString) AddN(n int, elements ...string) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetString) Remove(elements ...string) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetString) RemoveN(n int, elements ...string) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetString) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetString) Count(element string) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetString) Equal(other MultiSetString) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetUint type
type MultiSetUint map[uint]int

// NewUint creates new set
func NewUint() MultiSetUint {
	return make(map[uint]int)
}

// Add adds elements
func (s MultiSetUint) Add(elements ...uint) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetUint) AddN(n int, elements ...uint) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetUint) Remove(elements ...uint) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetUint) RemoveN(n int, elements ...uint) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetUint) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetUint) Count(element uint) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetUint) Equal(other MultiSetUint) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetUint16 type
type MultiSetUint16 map[uint16]int

// NewUint16 creates new set
func NewUint16() MultiSetUint16 {
	return make(map[uint16]int)
}

// Add adds elements
func (s MultiSetUint16) Add(elements ...uint16) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetUint16) AddN(n int, elements ...uint16) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetUint16) Remove(elements ...uint16) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetUint16) RemoveN(n int, elements ...uint16) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetUint16) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetUint16) Count(element uint16) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetUint16) Equal(other MultiSetUint16) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetUint32 type
type MultiSetUint32 map[uint32]int

// NewUint32 creates new set
func NewUint32() MultiSetUint32 {
	return make(map[uint32]int)
}

// Add adds elements
func (s MultiSetUint32) Add(elements ...uint32) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetUint32) AddN(n int, elements ...uint32) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetUint32) Remove(elements ...uint32) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetUint32) RemoveN(n int, elements ...uint32) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetUint32) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetUint32) Count(element uint32) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetUint32) Equal(other MultiSetUint32) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetUint64 type
type MultiSetUint64 map[uint64]int

// NewUint64 creates new set
func NewUint64() MultiSetUint64 {
	return make(map[uint64]int)
}

// Add adds elements
func (s MultiSetUint64) Add(elements ...uint64) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetUint64) AddN(n int, elements ...uint64) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetUint64) Remove(elements ...uint64) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetUint64) RemoveN(n int, elements ...uint64) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetUint64) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetUint64) Count(element uint64) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetUint64) Equal(other MultiSetUint64) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetUint8 type
type MultiSetUint8 map[uint8]int

// NewUint8 creates new set
func NewUint8() MultiSetUint8 {
	return make(map[uint8]int)
}

// Add adds elements
func (s MultiSetUint8) Add(elements ...uint8) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetUint8) AddN(n int, elements ...uint8) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetUint8) Remove(elements ...uint8) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetUint8) RemoveN(n int, elements ...uint8) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetUint8) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetUint8) Count(element uint8) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetUint8) Equal(other MultiSetUint8) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}

// MultiSetUintptr type
type MultiSetUintptr map[uintptr]int

// NewUintptr creates new set
func NewUintptr() MultiSetUintptr {
	return make(map[uintptr]int)
}

// Add adds elements
func (s MultiSetUintptr) Add(elements ...uintptr) {
	for _, element := range elements {
		s[element]++
	}
}

// AddN adds n elements
func (s MultiSetUintptr) AddN(n int, elements ...uintptr) {
	for _, element := range elements {
		s[element] += n
	}
}

// Remove elements
func (s MultiSetUintptr) Remove(elements ...uintptr) {
	for _, element := range elements {
		if s[element] >= 1 {
			s[element]--
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// RemoveN removes n elements
func (s MultiSetUintptr) RemoveN(n int, elements ...uintptr) {
	for _, element := range elements {
		if s[element] >= n {
			s[element] -= n
			if s[element] <= 0 {
				delete(s, element)
			}
		}
	}
}

// Len get set length
func (s MultiSetUintptr) Len() int {
	total := 0
	for _, count := range s {
		total += count
	}
	return total
}

// Count number of element in set
func (s MultiSetUintptr) Count(element uintptr) int {
	return s[element]
}

// Equal are multisets equal
func (s MultiSetUintptr) Equal(other MultiSetUintptr) bool {
	if s.Len() != other.Len() {
		return false
	}
	for element, count := range s {
		if other.Count(element) != count {
			return false
		}
	}
	return true
}
