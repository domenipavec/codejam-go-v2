// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package grid

// GridBool type
type GridBool [][]bool

// NewBool creates grid n by m
func NewBool(n, m int) GridBool {
	grid := make([][]bool, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]bool, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridBool) Copy() GridBool {
	newGrid := NewBool(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridBool) Set(c bool) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridBool) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridBool) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridBool) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridByte type
type GridByte [][]byte

// NewByte creates grid n by m
func NewByte(n, m int) GridByte {
	grid := make([][]byte, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]byte, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridByte) Copy() GridByte {
	newGrid := NewByte(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridByte) Set(c byte) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridByte) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridByte) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridByte) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridComplex128 type
type GridComplex128 [][]complex128

// NewComplex128 creates grid n by m
func NewComplex128(n, m int) GridComplex128 {
	grid := make([][]complex128, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]complex128, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridComplex128) Copy() GridComplex128 {
	newGrid := NewComplex128(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridComplex128) Set(c complex128) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridComplex128) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridComplex128) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridComplex128) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridComplex64 type
type GridComplex64 [][]complex64

// NewComplex64 creates grid n by m
func NewComplex64(n, m int) GridComplex64 {
	grid := make([][]complex64, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]complex64, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridComplex64) Copy() GridComplex64 {
	newGrid := NewComplex64(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridComplex64) Set(c complex64) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridComplex64) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridComplex64) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridComplex64) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridError type
type GridError [][]error

// NewError creates grid n by m
func NewError(n, m int) GridError {
	grid := make([][]error, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]error, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridError) Copy() GridError {
	newGrid := NewError(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridError) Set(c error) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridError) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridError) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridError) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridFloat32 type
type GridFloat32 [][]float32

// NewFloat32 creates grid n by m
func NewFloat32(n, m int) GridFloat32 {
	grid := make([][]float32, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]float32, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridFloat32) Copy() GridFloat32 {
	newGrid := NewFloat32(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridFloat32) Set(c float32) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridFloat32) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridFloat32) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridFloat32) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridFloat64 type
type GridFloat64 [][]float64

// NewFloat64 creates grid n by m
func NewFloat64(n, m int) GridFloat64 {
	grid := make([][]float64, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]float64, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridFloat64) Copy() GridFloat64 {
	newGrid := NewFloat64(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridFloat64) Set(c float64) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridFloat64) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridFloat64) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridFloat64) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridInt type
type GridInt [][]int

// NewInt creates grid n by m
func NewInt(n, m int) GridInt {
	grid := make([][]int, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]int, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridInt) Copy() GridInt {
	newGrid := NewInt(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridInt) Set(c int) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridInt) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridInt) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridInt) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridInt16 type
type GridInt16 [][]int16

// NewInt16 creates grid n by m
func NewInt16(n, m int) GridInt16 {
	grid := make([][]int16, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]int16, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridInt16) Copy() GridInt16 {
	newGrid := NewInt16(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridInt16) Set(c int16) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridInt16) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridInt16) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridInt16) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridInt32 type
type GridInt32 [][]int32

// NewInt32 creates grid n by m
func NewInt32(n, m int) GridInt32 {
	grid := make([][]int32, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]int32, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridInt32) Copy() GridInt32 {
	newGrid := NewInt32(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridInt32) Set(c int32) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridInt32) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridInt32) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridInt32) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridInt64 type
type GridInt64 [][]int64

// NewInt64 creates grid n by m
func NewInt64(n, m int) GridInt64 {
	grid := make([][]int64, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]int64, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridInt64) Copy() GridInt64 {
	newGrid := NewInt64(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridInt64) Set(c int64) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridInt64) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridInt64) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridInt64) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridInt8 type
type GridInt8 [][]int8

// NewInt8 creates grid n by m
func NewInt8(n, m int) GridInt8 {
	grid := make([][]int8, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]int8, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridInt8) Copy() GridInt8 {
	newGrid := NewInt8(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridInt8) Set(c int8) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridInt8) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridInt8) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridInt8) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridRune type
type GridRune [][]rune

// NewRune creates grid n by m
func NewRune(n, m int) GridRune {
	grid := make([][]rune, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]rune, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridRune) Copy() GridRune {
	newGrid := NewRune(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridRune) Set(c rune) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridRune) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridRune) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridRune) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridString type
type GridString [][]string

// NewString creates grid n by m
func NewString(n, m int) GridString {
	grid := make([][]string, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]string, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridString) Copy() GridString {
	newGrid := NewString(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridString) Set(c string) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridString) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridString) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridString) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridUint type
type GridUint [][]uint

// NewUint creates grid n by m
func NewUint(n, m int) GridUint {
	grid := make([][]uint, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]uint, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridUint) Copy() GridUint {
	newGrid := NewUint(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridUint) Set(c uint) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridUint) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridUint) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridUint) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridUint16 type
type GridUint16 [][]uint16

// NewUint16 creates grid n by m
func NewUint16(n, m int) GridUint16 {
	grid := make([][]uint16, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]uint16, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridUint16) Copy() GridUint16 {
	newGrid := NewUint16(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridUint16) Set(c uint16) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridUint16) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridUint16) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridUint16) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridUint32 type
type GridUint32 [][]uint32

// NewUint32 creates grid n by m
func NewUint32(n, m int) GridUint32 {
	grid := make([][]uint32, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]uint32, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridUint32) Copy() GridUint32 {
	newGrid := NewUint32(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridUint32) Set(c uint32) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridUint32) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridUint32) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridUint32) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridUint64 type
type GridUint64 [][]uint64

// NewUint64 creates grid n by m
func NewUint64(n, m int) GridUint64 {
	grid := make([][]uint64, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]uint64, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridUint64) Copy() GridUint64 {
	newGrid := NewUint64(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridUint64) Set(c uint64) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridUint64) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridUint64) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridUint64) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridUint8 type
type GridUint8 [][]uint8

// NewUint8 creates grid n by m
func NewUint8(n, m int) GridUint8 {
	grid := make([][]uint8, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]uint8, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridUint8) Copy() GridUint8 {
	newGrid := NewUint8(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridUint8) Set(c uint8) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridUint8) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridUint8) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridUint8) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}

// GridUintptr type
type GridUintptr [][]uintptr

// NewUintptr creates grid n by m
func NewUintptr(n, m int) GridUintptr {
	grid := make([][]uintptr, n)
	for i := 0; i < n; i++ {
		grid[i] = make([]uintptr, m)
	}
	return grid
}

// Copy makes a new independent copy of grid
func (grid GridUintptr) Copy() GridUintptr {
	newGrid := NewUintptr(len(grid), len(grid[0]))
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			newGrid[i][j] = grid[i][j]
		}
	}
	return newGrid
}

// Set sets all element to c
func (grid GridUintptr) Set(c uintptr) {
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			grid[i][j] = c
		}
	}
}

// SpiralIterator returns []Coordinate in spiral order
func (grid GridUintptr) SpiralIterator() []Coordinate {
	data := make([]Coordinate, len(grid)*len(grid[0]))
	return grid.spiralTopRight(data, 0, 0, len(grid)-1, len(grid[0])-1)
}

func (grid GridUintptr) spiralTopRight(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x1; j <= x2; j++ {
		data = append(data, Coordinate{I: y1, J: j})
	}

	for i := y1 + 1; i <= y2; i++ {
		data = append(data, Coordinate{I: i, J: x2})
	}

	if x2-x1 > 0 {
		data = grid.spiralBottomLeft(data, x1, y1+1, x2-1, y2)
	}

	return data
}

func (grid GridUintptr) spiralBottomLeft(data []Coordinate, x1, y1, x2, y2 int) []Coordinate {
	for j := x2; j >= x1; j-- {
		data = append(data, Coordinate{I: y2, J: j})
	}

	for i := y2 - 1; i >= y1; i-- {
		data = append(data, Coordinate{I: i, J: x1})
	}

	if x2-x1 > 0 {
		data = grid.spiralTopRight(data, x1+1, y1, x2, y2-1)
	}

	return data
}
